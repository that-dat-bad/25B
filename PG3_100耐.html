<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PG3 テスト対策 ランダム＆復習機能付</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --text-color: #333;
            --container-bg: #ffffff;
            --header-bg: #2c3e50;
            --header-text: #ffffff;
            --section-header: #34495e;
            --accent: #3498db;
            --correct-bg: #d4edda;
            --correct-color: #155724;
            --incorrect-bg: #f8d7da;
            --incorrect-color: #721c24;
            --border-color: #dee2e6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding-bottom: calc(100px + env(safe-area-inset-bottom));
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation;
        }

        .container {
            max-width: 800px;
            margin: 20px auto;
            background-color: var(--container-bg);
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        @media (max-width: 600px) {
            .container {
                margin: 0;
                border-radius: 0;
                padding: 15px 15px;
                box-shadow: none;
            }

            h1 {
                font-size: 1.2rem;
            }

            button {
                width: 100%;
                margin-bottom: 8px;
                padding: 14px;
                font-size: 16px;
            }

            .btn-group {
                flex-wrap: wrap;
            }

            /* コントロールボタンのレイアウト調整 */
            .controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
        }

        h1 {
            text-align: center;
            color: var(--header-bg);
            border-bottom: 3px solid var(--accent);
            padding-bottom: 15px;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .question-card {
            border-bottom: 1px solid var(--border-color);
            padding: 20px 0;
        }

            .question-card:last-child {
                border-bottom: none;
            }

        .q-header {
            display: flex;
            align-items: flex-start;
            font-weight: bold;
            font-size: 1.05em;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .q-num {
            color: var(--accent);
            min-width: 55px;
        }

        .q-tag {
            font-size: 0.8em;
            color: #666;
            background: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 8px;
            font-weight: normal;
        }

        .answer-section {
            margin-top: 15px;
            display: none;
        }

            .answer-section.visible {
                display: block;
                animation: fadeIn 0.3s ease-out;
            }

        .answer-text {
            background-color: #f8f9fa;
            border-left: 4px solid var(--accent);
            padding: 15px;
            margin-bottom: 15px;
            white-space: pre-wrap;
            line-height: 1.6;
        }

        .btn-group {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s, transform 0.1s;
            -webkit-appearance: none;
        }

            button:active {
                transform: scale(0.98);
            }

            button:hover {
                opacity: 0.9;
            }

        .btn-reset {
            background-color: #6c757d;
            color: white;
        }

        .btn-retry {
            background-color: #e74c3c;
            color: white;
        }

        .btn-show {
            background-color: var(--accent);
            color: white;
        }

        .btn-correct {
            background-color: #28a745;
            color: white;
        }

        .btn-incorrect {
            background-color: #dc3545;
            color: white;
        }

        .question-card.status-correct {
            background-color: var(--correct-bg);
            border-radius: 6px;
            padding: 10px;
        }

        .question-card.status-incorrect {
            background-color: var(--incorrect-bg);
            border-radius: 6px;
            padding: 10px;
        }

        .score-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--header-bg);
            color: white;
            padding: 15px;
            padding-bottom: calc(15px + env(safe-area-inset-bottom));
            text-align: center;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            font-size: 1.1em;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 999;
        }

        .empty-msg {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>PG3 対策<br>ランダム100選</h1>

        <div class="controls">
            <button class="btn-reset" onclick="window.startFullTest()">全問リセットして開始</button>
            <button class="btn-retry" onclick="window.startRetryMode()">間違った問題のみ復習</button>
        </div>

        <div id="quiz-container"></div>
    </div>

    <div class="score-bar">
        <div class="score-item">正解: <span id="score-correct">0</span> / <span id="score-total">0</span></div>
        <div class="score-item">率: <span id="score-rate">0</span>%</div>
    </div>

    <script>
        // 元データ（secはタグとして利用）
        const masterQuestions = [
            // 分野1: STL
            { q: "STLとは何の略称か。", a: "Standard Template Library", tag: "STL" },
            { q: "STLの3大構成要素を答えよ（コンテナ、○○○、アルゴリズム）。", a: "イテレータ (Iterator)", tag: "STL" },
            { q: "std::vector と std::list の主な違いを、メモリアクセスと挿入・削除の観点から説明せよ。", a: "vector：ランダムアクセスが高速、末尾以外への挿入削除は遅い。\nlist：ランダムアクセス不可、任意位置への挿入削除が高速。", tag: "STL" },
            { q: "std::vector において、末尾への要素追加を行うメンバ関数は何か。", a: "push_back()", tag: "STL" },
            { q: "std::vector の要素数を変更するメンバ関数は何か。", a: "resize()", tag: "STL" },
            { q: "std::vector の resize() と reserve() の違いを説明せよ。", a: "resize()：実際に要素数を変更・初期化する。\nreserve()：メモリ容量(capacity)だけ確保する。", tag: "STL" },
            { q: "双方向リストを使用するためにインクルードすべきヘッダファイル名は何か。", a: "#include list", tag: "STL" },
            { q: "std::list において、先頭に要素を追加するメンバ関数は何か。", a: "push_front()", tag: "STL" },
            { q: "std::list はランダムアクセス（list[3]のようなアクセス）が可能か。", a: "不可能", tag: "STL" },
            { q: "コンテナの要素を昇順に並べ替えるアルゴリズム関数は何か。", a: "std::sort()", tag: "STL" },
            { q: "std::sort を使用するためにインクルードすべきヘッダファイル名は何か。", a: "#include algorithm", tag: "STL" },
            { q: "std::find 関数が見つからなかった場合に返す値は何か。", a: "終端イテレータ (end())", tag: "STL" },
            { q: "コンテナ内の特定の条件を満たす要素の数を数えるアルゴリズム関数は何か。", a: "std::count()", tag: "STL" },
            { q: "コンテナの要素を逆順にするアルゴリズム関数は何か。", a: "std::reverse()", tag: "STL" },
            { q: "std::for_each の第3引数には何を渡す必要があるか。", a: "各要素に対して実行する関数", tag: "STL" },
            { q: "配列やコンテナの要素を指し示すポインタを抽象化したオブジェクトを何と呼ぶか。", a: "イテレータ (Iterator)", tag: "STL" },
            { q: "イテレータにおいて、コンテナの「最後の要素の次」を指すメンバ関数は何か。", a: "end()", tag: "STL" },
            { q: "std::vector で途中の要素を削除した際、それ以降の要素はどうなるか。", a: "前に詰められる（インデックスがずれる）", tag: "STL" },
            { q: "std::map はどのようなデータ構造でデータを管理するか。", a: "二分木 (赤黒木)", tag: "STL" },
            { q: "C++11以降、std::vector<int> v = {1, 2}; のような初期化は可能か。", a: "可能", tag: "STL" },

            // 分野2: テンプレート
            { q: "関数テンプレートを定義する際に使用するキーワードは何か。", a: "template", tag: "Template" },
            { q: "テンプレート引数 template <typename T> の T は一般的に何を表しているか。", a: "型 (Type)", tag: "Template" },
            { q: "関数テンプレート add<int>(a, b) のように型を明示して呼び出すことは可能か。", a: "可能", tag: "Template" },
            { q: "クラステンプレートにおいて、型パラメータを省略してインスタンス化することは可能か（C++17以前）。", a: "不可能 (Box<int> b; のように指定が必要)", tag: "Template" },
            { q: "異なる型を引数に取る関数テンプレートを作成する場合、テンプレート引数はいくつ必要か。", a: "2つ (例: template <typename T1, typename T2>)", tag: "Template" },
            { q: "テンプレートの「特殊化」とは何か。", a: "特定の型に対して、専用の処理を定義すること。", tag: "Template" },
            { q: "関数テンプレートの特殊化を行う際、template <> のように空の括弧を書く必要があるか。", a: "必要", tag: "Template" },
            { q: "関数のオーバーロードとテンプレートの特殊化の違いは？", a: "オーバーロードは別関数の定義。特殊化は同じテンプレートの例外定義。", tag: "Template" },
            { q: "クラステンプレートのメンバ関数をクラス外で定義する場合の記述は？", a: "template <typename T> クラス名<T>::関数名", tag: "Template" },
            { q: "テンプレートはコンパイル時と実行時、いつコードが生成されるか。", a: "コンパイル時", tag: "Template" },

            // 分野3: ラムダ式・function
            { q: "ラムダ式の基本構文 [ ]( ) { } の各括弧の役割は？", a: "[]:キャプチャ、():引数、{}:処理", tag: "Lambda" },
            { q: "ラムダ式において、外部変数をコピーキャプチャする記号は？", a: "=", tag: "Lambda" },
            { q: "ラムダ式において、外部変数を参照キャプチャする記号は？", a: "&", tag: "Lambda" },
            { q: "[=] と書いた場合、外部変数はどう扱われるか。", a: "全てコピーキャプチャ", tag: "Lambda" },
            { q: "[&] と書いた場合、外部変数はどう扱われるか。", a: "全て参照キャプチャ", tag: "Lambda" },
            { q: "ラムダ式内でメンバ変数にアクセスするためにキャプチャするものは？", a: "this", tag: "Lambda" },
            { q: "std::function を使用するために必要なヘッダは？", a: "#include functional", tag: "Lambda" },
            { q: "std::function<int(int)> はどんな型か。", a: "intを1つ受け取りintを返す関数型", tag: "Lambda" },
            { q: "関数ポインタと比較したstd::functionの利点は？", a: "キャプチャ付きラムダや関数オブジェクトも扱える点", tag: "Lambda" },
            { q: "ラムダ式が「無名関数」と呼ばれる理由は？", a: "名前を定義せずにその場で記述できるため", tag: "Lambda" },

            // 分野4: ポインタ
            { q: "関数ポインタとは何を格納する変数か。", a: "関数のメモリアドレス", tag: "Pointer" },
            { q: "戻り値void、引数なしの関数ポインタ宣言を書け。", a: "void (*p)();", tag: "Pointer" },
            { q: "関数ポインタを使用するメリットは？", a: "処理の動的切り替え、コールバックの実装", tag: "Pointer" },
            { q: "関数ポインタ p に関数 func を代入する際、&は必須か。", a: "必須ではない (関数名はアドレスに暗黙変換される)", tag: "Pointer" },
            { q: "typedef で関数ポインタ型を定義するメリットは？", a: "可読性の向上", tag: "Pointer" },
            { q: "メンバ関数ポインタの宣言で必要なものは？", a: "クラス名:: (例: void (A::*p)())", tag: "Pointer" },
            { q: "クラス MyClass のメンバ関数 Update へのポインタ pUpdate を宣言せよ（戻り値void、引数なし）。", a: "void (MyClass::*pUpdate)();", tag: "Pointer" },
            { q: "メンバ関数ポインタ実行時に必要なものは？", a: "インスタンス (this)", tag: "Pointer" },
            { q: "メンバ関数ポインタ配列によるステート管理のメリットは？", a: "if/switch文をなくし、インデックスで処理を切り替えられる", tag: "Pointer" },
            { q: "staticメンバ関数へのポインタは通常の関数ポインタとして扱えるか。", a: "扱える (this不要なため)", tag: "Pointer" },

            // 分野5: OOP
            { q: "ポリモーフィズムとは何か。", a: "同じ呼び出しで、オブジェクトに応じた異なる振る舞いをすること。", tag: "OOP" },
            { q: "ポリモーフィズム実現のために基底クラス関数に付けるキーワードは？", a: "virtual", tag: "OOP" },
            { q: "仮想関数の役割は？", a: "派生クラスでのオーバーライドを可能にする", tag: "OOP" },
            { q: "純粋仮想関数の宣言末尾に書くものは？", a: "= 0", tag: "OOP" },
            { q: "純粋仮想関数を持つクラスを何と呼ぶか。", a: "抽象クラス", tag: "OOP" },
            { q: "抽象クラスのインスタンスは生成できるか。", a: "できない", tag: "OOP" },
            { q: "インターフェイスとして機能するクラスの条件は？", a: "全てのメンバ関数が純粋仮想関数であること", tag: "OOP" },
            { q: "派生クラスで基底クラスの関数を上書きすることを何と呼ぶか。", a: "オーバーライド", tag: "OOP" },
            { q: "オーバーライドを明示するキーワードは？", a: "override", tag: "OOP" },
            { q: "継承時の基底クラスデストラクタには何を付けるべきか。", a: "virtual (仮想デストラクタ)", tag: "OOP" },
            { q: "仮想デストラクタにしないと起きる問題は？", a: "派生クラスのデストラクタが呼ばれずメモリリークする", tag: "OOP" },
            { q: "「is-aの関係」とは？", a: "継承関係 (例: 犬は動物)", tag: "OOP" },
            { q: "「has-aの関係」とは？", a: "包含関係 (例: 車はエンジンを持つ)", tag: "OOP" },
            { q: "UMLで斜体のクラス名は何を意味するか。", a: "抽象クラス", tag: "OOP" },
            { q: "依存関係の逆転原則では何に依存すべきか。", a: "抽象 (インターフェイス)", tag: "OOP" },

            // 分野6: マルチスレッド
            { q: "シングルスレッドとマルチスレッドの違いは？", a: "処理が順次行われるか、並行して行われるか", tag: "Thread" },
            { q: "std::thread を使うためのヘッダは？", a: "#include thread", tag: "Thread" },
            { q: "std::thread th(関数, 引数); 引数はどこに書くか。", a: "関数名の後の引数として", tag: "Thread" },
            { q: "スレッドの終了を待機する関数は？", a: "join()", tag: "Thread" },
            { q: "スレッドをdetachする理由は？", a: "メイン処理を止めずにバックグラウンドで動かすため", tag: "Thread" },
            { q: "排他制御(Mutex)はなぜ必要か。", a: "データ競合(Data Race)を防ぐため", tag: "Thread" },
            { q: "排他制御に使うクラスは std::mutex と何か。", a: "std::lock_guard など", tag: "Thread" },
            { q: "デッドロックとは？", a: "互いにリソース待ちをして処理が止まる状態", tag: "Thread" },
            { q: "lock/unlockを手動で呼ぶ危険性は？", a: "unlock忘れによるデッドロック", tag: "Thread" },
            { q: "スコープ離脱時に自動でロック解除するクラスは？", a: "std::lock_guard", tag: "Thread" },
            { q: "unique_lock と lock_guard の違いは？", a: "unique_lockは手動ロック操作や条件変数での待機が可能", tag: "Thread" },
            { q: "条件変数(condition_variable)の目的は？", a: "スレッドの待機(wait)と通知(notify)", tag: "Thread" },
            { q: "wait()の引数に必要なものは？", a: "unique_lock", tag: "Thread" },
            { q: "待機スレッドを再開させる関数は？", a: "notify_all() / notify_one()", tag: "Thread" },
            { q: "並行(Concurrent)と並列(Parallel)の違いは？", a: "並行は論理的な同時(切替)、並列は物理的な同時(複数コア)", tag: "Thread" },

            // 分野7: デザインパターン
            { q: "ステートパターンの目的は？", a: "状態をクラス化し振る舞いを切り替える", tag: "DesignPattern" },
            { q: "ステートパターンで改善できるコードの問題は？", a: "巨大なif/switch文", tag: "DesignPattern" },
            { q: "Stateクラスは通常何を継承するか。", a: "共通のインターフェイス", tag: "DesignPattern" },
            { q: "状態遷移とは？", a: "ある状態から別の状態へ移ること", tag: "DesignPattern" },
            { q: "シーン遷移にステートパターンを使う利点は？", a: "シーンごとの管理が独立し容易になる", tag: "DesignPattern" },
            { q: "Contextクラスの役割は？", a: "現在の状態を保持し、処理を委譲する", tag: "DesignPattern" },
            { q: "コマンドパターンの目的は？", a: "命令をオブジェクトとしてカプセル化する", tag: "DesignPattern" },
            { q: "コマンドパターンで命令はどう表現されるか。", a: "クラス(オブジェクト)", tag: "DesignPattern" },
            { q: "コマンドパターンで実現容易な機能は？", a: "Undo/Redo (履歴管理)", tag: "DesignPattern" },
            { q: "Invokerの役割は？", a: "コマンドを保持・実行する", tag: "DesignPattern" },
            { q: "コマンドにExecute()を持たせる理由は？", a: "実行者が中身を知らずに実行できるため", tag: "DesignPattern" },
            { q: "InputHandlerにコマンドパターンを使う利点は？", a: "入力と動作の疎結合化", tag: "DesignPattern" },
            { q: "ストラテジとステートの構造的類似点は？", a: "どちらもクラスを切り替えて振る舞いを変える", tag: "DesignPattern" },
            { q: "シングルトンパターンの目的は？", a: "インスタンスが1つであることを保証する", tag: "DesignPattern" },
            { q: "単一責任の原則のデザインパターンへの関わりは？", a: "1つのクラスが1つの役割に集中できる", tag: "DesignPattern" },

            // 分野8: その他
            { q: "日本語Windowsのレガシー文字コードは？", a: "Shift_JIS", tag: "Other" },
            { q: "世界標準の文字コードは？", a: "UTF-8", tag: "Other" },
            { q: "UTF-8のBOMが引き起こす問題は？", a: "コンパイルエラーや読み込み不良", tag: "Other" },
            { q: "VSで文字コードを統一する設定ファイルは？", a: ".editorconfig", tag: "Other" },
            { q: "再帰関数に必須なものは？", a: "終了条件 (ベースケース)", tag: "Other" }
        ];

        // 作業用変数
        let currentQuizList = [];
        let correctCount = 0;

        // オブジェクトにユニークIDと初期ステータスを付与して初期化
        // state: 'unanswered', 'correct', 'incorrect'
        masterQuestions.forEach((q, i) => {
            q.id = i;
            q.state = 'unanswered';
        });

        // シャッフル関数（Fisher-Yates）
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // 問題描画
        function renderQuestions() {
            const container = document.getElementById('quiz-container');
            container.innerHTML = "";

            if (currentQuizList.length === 0) {
                container.innerHTML = '<div class="empty-msg">対象となる問題がありません。<br>（全問正解済み、またはテストが開始されていません）</div>';
                return;
            }

            currentQuizList.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'question-card';
                if (item.state === 'correct') card.classList.add('status-correct');
                if (item.state === 'incorrect') card.classList.add('status-incorrect');
                card.id = `q-${index}`; // DOM上のID

                // HTML構築
                let answerSectionClass = 'answer-section';
                let showBtnStyle = 'display: block;';

                // 既に答えている場合の状態復元（UI上）
                // ※復習モードなどで再表示する場合、stateはリセットされている前提だが、
                // 途中経過保持などを考慮して実装

                card.innerHTML = `
                    <div class="q-header">
                        <span class="q-num">Q${index + 1}.</span>
                        <div>
                            <span class="q-tag">${item.tag}</span>
                            <span>${item.q}</span>
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn-show" id="btn-show-${index}" style="${showBtnStyle}" onclick="window.showAnswer(${index})">解答を表示</button>
                    </div>
                    <div class="${answerSectionClass}" id="ans-${index}">
                        <div class="answer-text"><strong>A.</strong> ${item.a}</div>
                        <div class="btn-group">
                            <button class="btn-correct" onclick="window.markResult(${index}, true)">〇 正解！</button>
                            <button class="btn-incorrect" onclick="window.markResult(${index}, false)">× 復習</button>
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });

            updateScore();
        }

        // 全問リセットしてスタート
        window.startFullTest = function () {
            if (confirm("全問題のステータスをリセットし、ランダム順でテストを開始しますか？")) {
                // ステータスリセット
                masterQuestions.forEach(q => q.state = 'unanswered');
                // 配列コピー＆シャッフル
                currentQuizList = shuffleArray([...masterQuestions]);
                correctCount = 0;
                renderQuestions();
                // スクロールをトップへ
                window.scrollTo(0, 0);
            }
        };

        // 間違った問題のみ抽出してリスタート
        window.startRetryMode = function () {
            // 現在「incorrect」になっているものを抽出
            const wrongQuestions = masterQuestions.filter(q => q.state === 'incorrect');

            if (wrongQuestions.length === 0) {
                alert("復習対象（不正解）の問題がありません。\nまずは全問テストを行ってください。");
                return;
            }

            if (confirm(`現在「不正解」となっている ${wrongQuestions.length} 問のみで再テストしますか？`)) {
                // 抽出した問題のステータスをリセットしてリスト化
                // ※ここでstateをunansweredに戻さないと、表示時に最初から赤色になってしまうためリセットする
                // ただし、masterQuestions側の記録としては「直前まで間違っていた」もの。
                // 今回のセッション用にオブジェクトの参照は維持しつつstate更新。
                wrongQuestions.forEach(q => q.state = 'unanswered');

                currentQuizList = shuffleArray([...wrongQuestions]);
                correctCount = 0;
                renderQuestions();
                window.scrollTo(0, 0);
            }
        };

        window.showAnswer = function (index) {
            const ansDiv = document.getElementById(`ans-${index}`);
            if (ansDiv) {
                ansDiv.classList.add('visible');
                const btn = document.getElementById(`btn-show-${index}`);
                if (btn) btn.style.display = 'none';
            }
        };

        // 結果記録
        window.markResult = function (index, isCorrect) {
            const item = currentQuizList[index]; // 参照を取得
            const card = document.getElementById(`q-${index}`);

            // 旧ステータスによるスコア調整（もし変更した場合）
            // 今回は「ボタンを押したら即座にステータス決定」とする
            if (item.state === 'correct') {
                correctCount--;
            }

            // 新ステータス適用
            item.state = isCorrect ? 'correct' : 'incorrect';

            // スコア加算
            if (isCorrect) correctCount++;

            // UI更新
            card.classList.remove('status-correct', 'status-incorrect');
            card.classList.add(isCorrect ? 'status-correct' : 'status-incorrect');

            updateScore();
        };

        function updateScore() {
            const total = currentQuizList.length;
            document.getElementById('score-correct').textContent = correctCount;
            document.getElementById('score-total').textContent = total;

            const rate = total > 0 ? Math.round((correctCount / total) * 100) : 0;
            document.getElementById('score-rate').textContent = rate;
        }

        // 初期ロード時は全問テスト開始
        window.onload = function () {
            // 自動で確認なしスタート
            currentQuizList = shuffleArray([...masterQuestions]);
            renderQuestions();
        };

    </script>

</body>
</html>